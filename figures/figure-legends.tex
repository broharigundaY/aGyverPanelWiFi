\subsection{Figure Legends}

\textbf{Figure \ref{fig:Fig1}. The git add/commit process.}
To store a snapshot of changes in your repository, first \verb|git add| any files to the staging area you wish to commit (for example, you've updated the \verb|process.sh| file).
Second, type \verb|git commit| with a message. Only files added to the staging area will be committed.
All past commits are located in the hidden \verb|.git| directory in your repository.

\textbf{Figure \ref{fig:Fig2}. Working with a local repository.}
A) To designate a directory on your computer as a Git repo, type the command \verb|git init|. 
This initializes the repository and will allow you to track the files located within that directory.
B) Once you have added a file, follow the git add/commit cycle to place the new file first into the staging area by typing \verb|git add| to designate it to be committed, and then \verb|git commit| to take the shapshot of that file. 
The commit is assigned a commit identifier (d75es) that can be used in the future to pull up this version or to compare different committed versions of this file.
C) As you continue to add and change files, you should regularly add and commit those changes. 
Here, an additional commit was done and the commit log now shows two commit identifiers: d75es (from step B) and f658t (the new commit).
Each commit will generate a unique identifier, which can be examined in reverse chronological order using \verb|git log|. 

\textbf{Figure \ref{fig:Fig3}. Working with both a local and remote repository as a single user.}
A) On your computer you commit to a Git repository (commit d75es).
B) On GitHub, you create a new repository called \verb|thesis|.
This repository is currently empty and not linked to the repo on your local machine.
C) The command \verb|git remote add| connects your local repository to your remote repository.
The remote repository is still empty, however, because you have not pushed any content to it.
D) You send all the local commits to the remote repository using the command \verb|git push|.
Only files that have been committed will appear in the remote repository.
E) You repeat several more rounds of updating scripts and committing on your local computer (commit f658t and then commit xv871).
You have not yet pushed these commits to the remote repository, so only the previously pushed commit is in the remote repo (commit d75es).
F) To bring the remote repository up-to-date with your local repository, you \verb|git push| the two new commits to the remote repository.
The local and remote repositories now contain the same files and commit histories.

\textbf{Figure \ref{fig:Fig4}. Contributing to Open Source Projects.}
You found an error in the README for a cool project hosted on GitHub and you would like to fix it.
A) The cool\_project repository exists on GitHub (along with the commit history of the project), but you would like to edit the README on your computer.
B) First, you fork the cool\_project repository into your account on GitHub, bringing the entire commit history of the project along with the code.
C) To create a copy of the repository on your computer, you \verb|git clone| the repository from your GitHub account.
D) You make a change to the README, save the file, add the file to the staging area, and commit (creating commit 09pr4).
This commit is only on your local computer.
Your remote cool\_project repository and the original remote cool\_project repository do not have this commit.
E) You sync your local and remote repositories using \verb|git push|.
The original cool\_project still does not have your update to the README file.
F) To suggest the change in the README to the original cool\_project team, submit a pull request via GitHub.
If the owner(s) of the cool\_project repository like your change, they will accept the pull request and your changes will be incorporated into the project.

  
  
  